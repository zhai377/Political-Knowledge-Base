<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>æ•°æ®è§£æä¸ºè¡¨æ ¼</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<style>
    body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 1500px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    text-align: center;
    color: #444;
}

.drop-zone {
    border: 2px dashed #ccc;
    border-radius: 10px;
    padding: 40px;
    text-align: center;
    margin: 20px 0;
    background-color: #f9f9f9;
    transition: all 0.3s ease;
}

.drop-zone.dragover {
    border-color: #4A90E2;
    background-color: #e3f2fd;
}

.drop-zone p {
    margin: 0;
    font-size: 18px;
    color: #666;
}

.drop-zone .file-info {
    margin-top: 10px;
    font-size: 14px;
    color: #888;
}

.file-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin: 20px 0;
    justify-content: center;
}

.file-tag {
    display: inline-flex;
    align-items: center;
    padding: 8px 15px;
    background-color: #4A90E2;
    color: white;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.file-tag:hover {
    background-color: #357ABD;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.file-tag.active {
    background-color: #28a745;
}

.file-tag.inactive {
    background-color: #6c757d;
    opacity: 0.6;
}

.file-tag .remove-btn {
    margin-left: 8px;
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 16px;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.file-tag .remove-btn:hover {
    background-color: rgba(255,255,255,0.2);
}

.file-tag .file-count {
    margin-left: 8px;
    background-color: rgba(255,255,255,0.2);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 12px;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
}

th,
td {
    border: 1px solid #ddd;
    padding: 12px 15px;
    text-align: left;
}

th {
    background-color: #f4f4f4;
    font-weight: bold;
    text-align: center;
}

.row-odd {
    background-color: #f5fcf5;
}

.row-even {
    background-color: #fff5f6;
}

tr:hover {
    background-color: #d5e9ff;
}

.col-index {
    width: 8%;
    text-align: center;
}

.index-checkbox {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.index-checkbox input[type="checkbox"] {
    margin: 0;
    cursor: pointer;
}

.row-selected {
    background-color: #f4e4d4 !important;
}

.row-selected:hover {
    background-color: #e8d4c0 !important;
}

.context-menu {
    position: fixed;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 5px 0;
    z-index: 1000;
    display: none;
}

.context-menu-item {
    padding: 8px 15px;
    cursor: pointer;
    font-size: 14px;
    color: #333;
}

.context-menu-item:hover {
    background-color: #f5f5f5;
}

.copy-success {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #28a745;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 14px;
    z-index: 1001;
    display: none;
}

.row-copied {
    color: #0066cc !important;
    font-weight: bold !important;
    transition: all 0.3s ease;
}

.batch-copy-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1002;
    background-color: #4A90E2;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 15px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.batch-copy-btn:hover {
    background-color: #357ABD;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.batch-copy-btn:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* ä¸»é¢˜åˆ‡æ¢æŒ‰é’®æ ·å¼ */
.theme-toggle-btn {
    position: fixed;
    top: 70px;
    right: 20px;
    z-index: 1002;
    background-color: #4A90E2;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 15px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.theme-toggle-btn:hover {
    background-color: #357ABD;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* æ·±è‰²æ¨¡å¼æ ·å¼ */
body.dark-mode {
    background-color: #1a1a1a;
    color: #e0e0e0;
}

body.dark-mode h1 {
    color: #ffffff;
}

body.dark-mode .drop-zone {
    background-color: #2d2d2d;
    border-color: #555;
}

body.dark-mode .drop-zone p {
    color: #b0b0b0;
}

body.dark-mode .drop-zone .file-info {
    color: #888;
}

body.dark-mode .file-tag {
    background-color: #4A90E2;
}

body.dark-mode .file-tag.inactive {
    background-color: #555;
}

body.dark-mode table {
    box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
}

body.dark-mode th,
body.dark-mode td {
    border-color: #555;
}

body.dark-mode th {
    background-color: #333;
    color: #ffffff;
}

body.dark-mode .row-odd {
    background-color: #2a2a2a;
}

body.dark-mode .row-even {
    background-color: #333;
}

body.dark-mode tr:hover {
    background-color: #404040;
}

body.dark-mode .row-selected {
    background-color: #4a3a2a !important;
}

body.dark-mode .row-selected:hover {
    background-color: #5a4a3a !important;
}

body.dark-mode .context-menu {
    background: #2d2d2d;
    border-color: #555;
}

body.dark-mode .context-menu-item {
    color: #e0e0e0;
}

body.dark-mode .context-menu-item:hover {
    background-color: #404040;
}

body.dark-mode .search-buttons button {
    background-color: #333;
    color: #e0e0e0;
    border-color: #555;
}

body.dark-mode .search-buttons button:hover {
    background-color: #404040;
}

body.dark-mode .search-buttons button.selected {
    background-color: #614caf;
    color: white;
}

body.dark-mode .search-container {
    background: #1a1a1a;
}

body.dark-mode #searchInput {
    background-color: #333;
    color: #e0e0e0;
    border: 1px solid #555;
}

body.dark-mode #searchInput::placeholder {
    color: #888;
}

body.dark-mode #clearBtn {
    color: #b0b0b0;
}

body.dark-mode #clearBtn:hover {
    color: #e0e0e0;
}

body.dark-mode .no-data {
    color: #888;
}

body.dark-mode #chartContainer {
    background-color: #2d2d2d;
    border-color: #555;
}

body.dark-mode #closeChart {
    background-color: #333;
    color: #e0e0e0;
}

body.dark-mode #closeChart:hover {
    background-color: #404040;
}

body.dark-mode .chart-type-btn {
    background-color: #333;
    color: #e0e0e0;
    border-color: #555;
}

body.dark-mode .chart-type-btn:hover {
    background-color: #404040;
}

body.dark-mode .chart-type-btn.active {
    background-color: #4CAF50;
    color: white;
    border-color: #4CAF50;
}

/* ç›¸ä¼¼é¢˜ç›®æ¨èæŒ‰é’®æ ·å¼ */
#showRecommendButton {
    position: fixed;
    bottom: 65px;
    left: 20px;
    z-index: 1000;
    padding: 10px 20px;
    background-color: #9C27B0;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 15px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}

#showRecommendButton:hover {
    background-color: #7B1FA2;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* æ¨èé¢æ¿å®¹å™¨æ ·å¼ */
#recommendContainer {
    width: 90%;
    height: 80%;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    border: 1px solid #ddd;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    display: none;
    z-index: 1000;
    overflow: hidden;
}

#recommendContent {
    height: 100%;
    overflow-y: auto;
    padding: 20px;
}

#closeRecommend {
    position: absolute;
    top: 10px;
    right: 15px;
    cursor: pointer;
    font-size: 24px;
    background-color: #f2f2f2;
    border: none;
    border-radius: 50%;
    width: 35px;
    height: 35px;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1001;
}

#closeRecommend:hover {
    background-color: #e0e0e0;
}

.recommend-section {
    margin-bottom: 30px;
    padding: 20px;
    background-color: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #9C27B0;
    position: relative;
}

.recommend-section h3 {
    margin: 0 0 15px 0;
    color: #333;
    font-size: 18px;
    font-weight: bold;
}

.recommend-item {
    background: white;
    padding: 15px;
    padding-left: 45px;
    margin-bottom: 10px;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.recommend-item.item-copied {
    background-color: #f3e5f5;
    transition: background-color 0.3s ease;
}

.recommend-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.recommend-item .title {
    font-weight: bold;
    color: #333;
    margin-bottom: 8px;
}

.recommend-item .points {
    color: #666;
    font-size: 14px;
    margin-bottom: 5px;
}

.recommend-item .filename {
    color: #999;
    font-size: 12px;
}

.recommend-item .item-number {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    background-color: #9C27B0;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
}

.recommend-item .similarity {
    float: right;
    background-color: #9C27B0;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
}

.no-recommendations {
    text-align: center;
    padding: 40px;
    color: #888;
    font-style: italic;
}

/* ç›¸ä¼¼ä¾æ®è€ƒç‚¹æ ·å¼ */
.similarity-point {
    font-weight: bold;
    color: #e91e63 !important;
    text-shadow: 0 0 2px rgba(233, 30, 99, 0.3);
}

body.dark-mode .similarity-point {
    color: #ff6b9d !important;
    text-shadow: 0 0 3px rgba(255, 107, 157, 0.5);
}

/* æ·±è‰²æ¨¡å¼ä¸‹çš„æ¨èé¢æ¿æ ·å¼ */
body.dark-mode #recommendContainer {
    background-color: #2d2d2d;
    border-color: #555;
}

body.dark-mode .recommend-section {
    background-color: #333;
    border-left-color: #9C27B0;
}

/* æ¨èåŒºå—å†…æ‰¹é‡å¤åˆ¶æŒ‰é’® */
.section-batch-copy {
    position: absolute;
    top: 12px;
    right: 12px;
    background-color: #9C27B0;
    color: #fff;
    border: none;
    border-radius: 16px;
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.section-batch-copy:hover {
    background-color: #7B1FA2;
}

body.dark-mode .section-batch-copy {
    background-color: #7B1FA2;
}

body.dark-mode .recommend-section h3 {
    color: #e0e0e0;
}

body.dark-mode .recommend-item {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .recommend-item.item-copied {
    background-color: #4a2a4a;
}

body.dark-mode .recommend-item .title {
    color: #ffffff;
}

body.dark-mode .recommend-item .points {
    color: #b0b0b0;
}

body.dark-mode .recommend-item .filename {
    color: #888;
}

body.dark-mode #closeRecommend {
    background-color: #333;
    color: #e0e0e0;
}

body.dark-mode #closeRecommend:hover {
    background-color: #404040;
}

body.dark-mode .no-recommendations {
    color: #888;
}

body.dark-mode #recommendContainer .similarity-point {
    color: #ff6b9d !important;
}

/* ç»Ÿè®¡é¢æ¿æŒ‰é’®æ ·å¼ */
#showStatsButton {
    position: fixed;
    top: 70px;
    left: 20px;
    z-index: 1000;
    padding: 8px 15px;
    background-color: #FF6B35;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}

#showStatsButton:hover {
    background-color: #E55A2B;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* ç»Ÿè®¡é¢æ¿å®¹å™¨æ ·å¼ */
#statsContainer {
    width: 90%;
    height: 80%;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    border: 1px solid #ddd;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    display: none;
    z-index: 1000;
    overflow: hidden;
}

#statsContent {
    height: 100%;
    overflow-y: auto;
    padding: 20px;
}

#closeStats {
    position: absolute;
    top: 10px;
    right: 15px;
    cursor: pointer;
    font-size: 24px;
    background-color: #f2f2f2;
    border: none;
    border-radius: 50%;
    width: 35px;
    height: 35px;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1001;
}

#closeStats:hover {
    background-color: #e0e0e0;
}

.stats-section {
    margin-bottom: 30px;
    padding: 20px;
    background-color: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #4A90E2;
}

.stats-section h3 {
    margin: 0 0 15px 0;
    color: #333;
    font-size: 18px;
    font-weight: bold;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.stats-card {
    background: white;
    padding: 15px;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    text-align: center;
}

.stats-card .number {
    font-size: 24px;
    font-weight: bold;
    color: #4A90E2;
    margin-bottom: 5px;
}

.stats-card .label {
    font-size: 14px;
    color: #666;
}

.stats-list {
    max-height: 200px;
    overflow-y: auto;
    background: white;
    border-radius: 6px;
    padding: 10px;
}

.stats-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}

.stats-item:last-child {
    border-bottom: none;
}

.stats-item .name {
    font-weight: 500;
}

.stats-item .count {
    background-color: #4A90E2;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
}

.stats-chart {
    height: 300px;
    margin-top: 15px;
}

/* æ·±è‰²æ¨¡å¼ä¸‹çš„ç»Ÿè®¡é¢æ¿æ ·å¼ */
body.dark-mode #statsContainer {
    background-color: #2d2d2d;
    border-color: #555;
}

body.dark-mode .stats-section {
    background-color: #333;
    border-left-color: #4A90E2;
}

body.dark-mode .stats-section h3 {
    color: #e0e0e0;
}

body.dark-mode .stats-card {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .stats-card .label {
    color: #b0b0b0;
}

body.dark-mode .stats-list {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .stats-item {
    border-bottom-color: #555;
}

body.dark-mode #closeStats {
    background-color: #333;
    color: #e0e0e0;
}

body.dark-mode #closeStats:hover {
    background-color: #404040;
}

/* å›¾è¡¨æŒ‰é’®æ ·å¼ */
#showChartButton {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 1000;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 15px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}

#showChartButton:hover {
    background-color: #3e8e41;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#showChartButton:hover {
    background-color: #3e8e41;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* å›¾è¡¨å®¹å™¨æ ·å¼ */
#chartContainer {
    width: 90%;
    height: 80%;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    border: 1px solid #ddd;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    display: none;
    z-index: 1000;
    overflow: hidden;
}

#chart {
    position: relative;
    height: 600px;
    margin-top: 20px;
    padding: 20px;
    overflow: auto;
}

/* å›¾è¡¨ç±»å‹é€‰æ‹©å™¨æ ·å¼ */
.chart-type-selector {
    position: absolute;
    top: 50px;
    left: 20px;
    display: flex;
    gap: 10px;
    z-index: 1001;
}

.chart-type-btn {
    padding: 8px 12px;
    background-color: #f0f0f0;
    color: #333;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.3s ease;
}

.chart-type-btn:hover {
    background-color: #e0e0e0;
}

.chart-type-btn.active {
    background-color: #4CAF50;
    color: white;
    border-color: #4CAF50;
}

#closeChart {
    position: absolute;
    top: 5px;
    right: 10px;
    cursor: pointer;
    font-size: 18px;
    background-color: #f2f2f2;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* æ»‘åŠ¨æ¡å®¹å™¨æ ·å¼ */
.slider-container {
    position: absolute;
    top: 50px;
    right: 10px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    z-index: 1001;
}

.slider-container input {
    margin: 5px 0;
}

.slider-label {
    font-size: 14px;
    margin-right: 5px;
}

/* è¦†ç›–å±‚æ ·å¼ */
#overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 999;
    display: none;
}

/* æœç´¢æ¨¡å¼æŒ‰é’®æ ·å¼ */
.search-buttons {
    display: flex;
    justify-content: center;
    margin-top: 10px;
}

.search-buttons button {
    margin: 0 5px;
    padding: 8px 16px;
    background-color: #f0f0f0;
    color: #333;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
}

.search-buttons button:hover {
    background-color: #e0e0e0;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.search-buttons button.selected {
    background-color: #614caf;
    color: white;
    border-color: #704382;
}

.col-title {
    width: 15%;
}

.col-points {
    width: 65%;
}

.col-filename {
    width: 15%;
    text-align: center;
}

.search-container {
    position: sticky;
    top: 10px;
    z-index: 1;
    background: #fff;
    padding-bottom: 20px;
}

.search-box {
    position: relative;
    width: 60%;
    margin-left: 20%;
}

#searchInput {
    width: 100%;
    padding: 10px;
    padding-right: 30px;
    box-sizing: border-box;
    font-size: 16px;
}

#clearBtn {
    display: none;
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    cursor: pointer;
    font-size: 22px;
    color: #888;
}
#clearBtn:hover {
    color: #333;
}

#rowCountContainer {
    position: fixed;
    top: 2%;
    left: 20px;
    padding: 8px 15px;
    background-color: #28a745;
    color: white;
    border-radius: 5px;
    font-size: 14px;
    font-weight: bold;
    z-index: 1002;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#scrollToTopBtn {
    display: none;
    position: fixed;
    bottom: 30px;
    right: 30px;
    width: 50px;
    height: 50px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    z-index: 1001;
    transition: all 0.3s ease;
}

#scrollToTopBtn:hover {
    background-color: #0056b3;
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.no-data {
    text-align: center;
    padding: 40px;
    color: #888;
    font-style: italic;
}
</style>
</head>

<body>
    <div id="rowCountContainer"></div>
    <button id="scrollToTopBtn" title="å›åˆ°é¡¶éƒ¨">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 15 12 9 18 15"></polyline>
        </svg>
    </button>
    <button id="batchCopyBtn" class="batch-copy-btn" disabled>æ‰¹é‡å¤åˆ¶</button>
    <button id="themeToggleBtn" class="theme-toggle-btn">ğŸŒ™ æ·±è‰²æ¨¡å¼</button>
    
    <!-- å›¾è¡¨æŒ‰é’® -->
    <button id="showChartButton">ğŸ“Š æ•°æ®å›¾è¡¨</button>
    
    <!-- ç›¸ä¼¼é¢˜ç›®æ¨èæŒ‰é’® -->
    <button id="showRecommendButton">ğŸ¯ ç›¸ä¼¼é¢˜ç›®</button>
    
    <!-- ç»Ÿè®¡é¢æ¿æŒ‰é’® -->
    <button id="showStatsButton">ğŸ“Š ç»Ÿè®¡é¢æ¿</button>
    
    <!-- å›¾è¡¨å®¹å™¨ -->
    <div id="overlay"></div>
    <div id="chartContainer">
        <button id="closeChart">Ã—</button>
        <div class="chart-type-selector">
            <button class="chart-type-btn active" data-type="bar">æ¡å½¢å›¾</button>
            <button class="chart-type-btn" data-type="pie">é¥¼å›¾</button>
            <button class="chart-type-btn" data-type="doughnut">ç¯å½¢å›¾</button>
            <button class="chart-type-btn" data-type="line">æŠ˜çº¿å›¾</button>
            <button class="chart-type-btn" data-type="radar">é›·è¾¾å›¾</button>
        </div>
        <canvas id="chart"></canvas>
        <div class="slider-container">
            <div>
                <span class="slider-label">æœ€å°å€¼:</span>
                <span id="minRangeValue">0</span>
                <input type="range" id="minRange" min="0" max="100" value="0">
            </div>
            <div>
                <span class="slider-label">æœ€å¤§å€¼:</span>
                <span id="maxRangeValue">100</span>
                <input type="range" id="maxRange" min="0" max="100" value="100">
            </div>
        </div>
    </div>
    
    <!-- ç»Ÿè®¡é¢æ¿å®¹å™¨ -->
    <div id="statsContainer">
        <button id="closeStats">Ã—</button>
        <div id="statsContent">
            <!-- ç»Ÿè®¡å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
    
    <!-- ç›¸ä¼¼é¢˜ç›®æ¨èé¢æ¿å®¹å™¨ -->
    <div id="recommendContainer">
        <button id="closeRecommend">Ã—</button>
        <div id="recommendContent">
            <!-- æ¨èå†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
    
    <!-- å¤åˆ¶æˆåŠŸæç¤º -->
    <div id="copySuccess" class="copy-success">å¤åˆ¶æˆåŠŸï¼</div>

    <h1>é¢˜ç›®æ•°æ®</h1>
    
    <div class="drop-zone" id="dropZone">
        <p>å°†å¤šä¸ª Markdown æ–‡ä»¶æ‹–æ‹½åˆ°æ­¤å¤„</p>
        <div class="file-info" id="fileInfo"></div>
    </div>

    <div class="file-tags" id="fileTags"></div>

    <div class="search-container">
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="è¾“å…¥æœç´¢å†…å®¹ï¼Œé€—å·éš”å¼€">
            <span id="clearBtn">&times;</span>
        </div>
    </div>

    <!-- æœç´¢æ¨¡å¼æŒ‰é’® -->
    <div class="search-buttons">
        <button id="partialOrMatchButton" onclick="toggleSearchMode('partialOr')">éƒ¨åˆ†åŒ¹é…ï¼ˆæˆ–ï¼‰</button>
        <button id="partialAndMatchButton" onclick="toggleSearchMode('partialAnd')">éƒ¨åˆ†åŒ¹é…ï¼ˆä¸”ï¼‰</button>
        <button id="exactMatchButton" onclick="toggleSearchMode('exact')">ç²¾ç¡®åŒ¹é…ï¼ˆä¸”ï¼‰</button>
    </div>
    
    <table id="dataTable">
        <thead>
            <tr>
                <th class="col-index">
                    <div class="index-checkbox">
                        <input type="checkbox" id="selectAllCheckbox">
                        <span>åºå·</span>
                    </div>
                </th>
                <th class="col-title">é¢˜ç›®å</th>
                <th class="col-points">è€ƒç‚¹åˆ—è¡¨</th>
                <th class="col-filename">æ–‡ä»¶å</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td colspan="4" class="no-data">è¯·æ‹–æ‹½ Markdown æ–‡ä»¶åˆ°ä¸Šæ–¹åŒºåŸŸ</td>
            </tr>
        </tbody>
    </table>

    <script>
        let data = {};
let fileData = {}; // å­˜å‚¨æ¯ä¸ªæ–‡ä»¶çš„æ•°æ®
let activeFiles = new Set(); // å­˜å‚¨å½“å‰æ¿€æ´»çš„æ–‡ä»¶
let fileOrder = []; // å­˜å‚¨æ–‡ä»¶çš„åŸå§‹é¡ºåº
let selectedRows = new Set(); // å­˜å‚¨é€‰ä¸­çš„è¡Œ
let pointCounts = {}; // å­˜å‚¨è€ƒç‚¹è®¡æ•°
let difficultyCounts = {}; // å­˜å‚¨éš¾åº¦è®¡æ•°
let typeCounts = {}; // å­˜å‚¨é¢˜å‹è®¡æ•°
let subjectCounts = {}; // å­˜å‚¨ç§‘ç›®è®¡æ•°
let chartInstance = null; // ç”¨äºå­˜å‚¨å›¾è¡¨å®ä¾‹
let currentChartType = 'bar'; // å½“å‰å›¾è¡¨ç±»å‹
let searchMode = 'partialOr'; // é»˜è®¤æ˜¯"æˆ–"æ¨¡å¼
let isDarkMode = false; // æ·±è‰²æ¨¡å¼çŠ¶æ€
const tableBody = document.querySelector('#dataTable tbody');
const dropZone = document.getElementById('dropZone');
const fileInfo = document.getElementById('fileInfo');
const fileTags = document.getElementById('fileTags');
const searchInput = document.getElementById('searchInput');
const clearBtn = document.getElementById('clearBtn');
const rowCountContainer = document.getElementById('rowCountContainer');
const copySuccess = document.getElementById('copySuccess');
const selectAllCheckbox = document.getElementById('selectAllCheckbox');
const batchCopyBtn = document.getElementById('batchCopyBtn');
const showChartButton = document.getElementById('showChartButton');
const closeChart = document.getElementById('closeChart');
const chartContainer = document.getElementById('chartContainer');
const overlay = document.getElementById('overlay');
const themeToggleBtn = document.getElementById('themeToggleBtn');
const showStatsButton = document.getElementById('showStatsButton');
const closeStats = document.getElementById('closeStats');
const statsContainer = document.getElementById('statsContainer');
const statsContent = document.getElementById('statsContent');
const showRecommendButton = document.getElementById('showRecommendButton');
const closeRecommend = document.getElementById('closeRecommend');
const recommendContainer = document.getElementById('recommendContainer');
const recommendContent = document.getElementById('recommendContent');
let buttons = {}; // ç”¨äºå­˜å‚¨æŒ‰é’®å…ƒç´ 

// è§£æ Markdown æ–‡ä»¶å†…å®¹
function parseMarkdown(content, filename) {
    const lines = content.split('\n');
    const parsedData = {};
    let currentTitle = '';
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // åŒ¹é…å››çº§æ ‡é¢˜ (####)
        if (line.startsWith('#### ')) {
            currentTitle = line.substring(5).trim();
            parsedData[currentTitle] = {
                points: [],
                filename: filename
            };
        }
        
        // åŒ¹é…äº”çº§æ ‡é¢˜ä¸­çš„è€ƒç‚¹ä¿¡æ¯
        if (line.startsWith('##### ï¼ˆè€ƒç‚¹ï¼šï¼‰ã€') && currentTitle) {
            console.log('æ‰¾åˆ°è€ƒç‚¹è¡Œ:', line); // è°ƒè¯•ä¿¡æ¯
            
            // ä½¿ç”¨æ›´ç®€å•çš„å­—ç¬¦ä¸²åŒ¹é…æ–¹æ³•
            const startIndex = line.indexOf('ã€');
            const endIndex = line.indexOf('ã€‘');
            
            if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                const content = line.substring(startIndex + 1, endIndex);
                console.log('æå–çš„å†…å®¹:', content); // è°ƒè¯•ä¿¡æ¯
                const points = content.split('ï¼Œ').map(point => point.trim());
                parsedData[currentTitle].points = points;
                console.log('è§£æçš„è€ƒç‚¹:', points); // è°ƒè¯•ä¿¡æ¯
            } else {
                console.log('å­—ç¬¦ä¸²åŒ¹é…å¤±è´¥'); // è°ƒè¯•ä¿¡æ¯
            }
        }
    }
    
    console.log('è§£æç»“æœ:', parsedData); // æ·»åŠ è°ƒè¯•ä¿¡æ¯
    return parsedData;
}

// åˆ›å»ºæ–‡ä»¶æ ‡ç­¾
function createFileTag(filename, count) {
    const tag = document.createElement('div');
    tag.className = 'file-tag active';
    tag.dataset.filename = filename;
    
    const filenameSpan = document.createElement('span');
    filenameSpan.textContent = filename;
    
    const countSpan = document.createElement('span');
    countSpan.className = 'file-count';
    countSpan.textContent = count;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.innerHTML = 'Ã—';
    removeBtn.title = 'ç§»é™¤æ–‡ä»¶';
    
    tag.appendChild(filenameSpan);
    tag.appendChild(countSpan);
    tag.appendChild(removeBtn);
    
    // ç‚¹å‡»æ ‡ç­¾åˆ‡æ¢æ¿€æ´»çŠ¶æ€
    tag.addEventListener('click', function(e) {
        if (e.target !== removeBtn) {
            toggleFileActive(filename);
        }
    });
    
    // ç‚¹å‡»ç§»é™¤æŒ‰é’®
    removeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        removeFile(filename);
    });
    
    return tag;
}

// åˆ‡æ¢æ–‡ä»¶æ¿€æ´»çŠ¶æ€
function toggleFileActive(filename) {
    const tag = document.querySelector(`[data-filename="${filename}"]`);
    if (activeFiles.has(filename)) {
        activeFiles.delete(filename);
        tag.classList.remove('active');
        tag.classList.add('inactive');
    } else {
        activeFiles.add(filename);
        tag.classList.remove('inactive');
        tag.classList.add('active');
    }
    updateTable();
    updateFileInfo(); // æ›´æ–°æ–‡ä»¶ä¿¡æ¯
}

// ç§»é™¤æ–‡ä»¶
function removeFile(filename) {
    delete fileData[filename];
    activeFiles.delete(filename);
    // ä»æ–‡ä»¶é¡ºåºä¸­ç§»é™¤
    const index = fileOrder.indexOf(filename);
    if (index > -1) {
        fileOrder.splice(index, 1);
    }
    updateFileTags();
    updateTable();
    updateFileInfo(); // ç¡®ä¿æ–‡ä»¶ä¿¡æ¯æ›´æ–°
}

// æ›´æ–°æ–‡ä»¶æ ‡ç­¾
function updateFileTags() {
    fileTags.innerHTML = '';
    // æŒ‰ç…§åŸå§‹æ–‡ä»¶é¡ºåºæ˜¾ç¤ºæ ‡ç­¾
    for (const filename of fileOrder) {
        if (fileData[filename]) {
            const count = Object.keys(fileData[filename]).length;
            const tag = createFileTag(filename, count);
            if (!activeFiles.has(filename)) {
                tag.classList.remove('active');
                tag.classList.add('inactive');
            }
            fileTags.appendChild(tag);
        }
    }
}

// æ›´æ–°æ–‡ä»¶ä¿¡æ¯
function updateFileInfo() {
    const totalFiles = Object.keys(fileData).length;
    const activeFileCount = activeFiles.size;
    
    // è®¡ç®—æ¿€æ´»æ–‡ä»¶çš„æ€»é¢˜ç›®æ•°
    let totalQuestions = 0;
    for (const filename of activeFiles) {
        if (fileData[filename]) {
            totalQuestions += Object.keys(fileData[filename]).length;
        }
    }
    
    if (totalFiles === 0) {
        fileInfo.textContent = 'è¯·æ‹–æ‹½ Markdown æ–‡ä»¶åˆ°ä¸Šæ–¹åŒºåŸŸ';
    } else {
        fileInfo.textContent = `å·²åŠ è½½ ${totalFiles} ä¸ªæ–‡ä»¶ï¼Œ${activeFileCount} ä¸ªæ¿€æ´»ï¼Œå…± ${totalQuestions} é“é¢˜ç›®`;
    }
}

// åˆå¹¶æ‰€æœ‰æ¿€æ´»æ–‡ä»¶çš„æ•°æ®
function mergeActiveData() {
    data = {};
    // æŒ‰ç…§åŸå§‹æ–‡ä»¶é¡ºåºåˆå¹¶æ•°æ®
    for (const filename of fileOrder) {
        if (activeFiles.has(filename) && fileData[filename]) {
            Object.assign(data, fileData[filename]);
        }
    }
}

// æ›´æ–°è¡¨æ ¼
function updateTable() {
    mergeActiveData();
    tableBody.innerHTML = '';
    selectedRows.clear(); // æ¸…ç©ºé€‰ä¸­çŠ¶æ€
    pointCounts = {}; // é‡ç½®è€ƒç‚¹è®¡æ•°
    difficultyCounts = {}; // é‡ç½®éš¾åº¦è®¡æ•°
    typeCounts = {}; // é‡ç½®é¢˜å‹è®¡æ•°
    subjectCounts = {}; // é‡ç½®ç§‘ç›®è®¡æ•°
    
    if (Object.keys(data).length === 0) {
        const noDataRow = document.createElement('tr');
        noDataRow.innerHTML = '<td colspan="4" class="no-data">è¯·æ‹–æ‹½ Markdown æ–‡ä»¶åˆ°ä¸Šæ–¹åŒºåŸŸæˆ–æ¿€æ´»æ–‡ä»¶</td>';
        tableBody.appendChild(noDataRow);
        return;
    }
    
    let index = 1;
    for (const title in data) {
        if (Object.prototype.hasOwnProperty.call(data, title)) {
            const keyPoints = data[title];
            const row = document.createElement('tr');
            row.dataset.title = title; // ä¸ºè¡Œæ·»åŠ æ•°æ®æ ‡è¯†

            const cellIndex = document.createElement('td');
            cellIndex.className = 'col-index';
            
            // åˆ›å»ºå¤é€‰æ¡†å’Œæ•°å­—çš„ç»„åˆ
            const indexContent = document.createElement('div');
            indexContent.className = 'index-checkbox';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.dataset.index = index;
            
            const numberSpan = document.createElement('span');
            numberSpan.textContent = index;
            
            indexContent.appendChild(checkbox);
            indexContent.appendChild(numberSpan);
            
            index++; // ç§»åˆ°åé¢
            cellIndex.appendChild(indexContent);
            row.appendChild(cellIndex);

            const cellTitle = document.createElement('td');
            cellTitle.textContent = title;
            row.appendChild(cellTitle);

            const cellKeyPoints = document.createElement('td');
            cellKeyPoints.textContent = keyPoints.points.join('ï¼Œ');
            row.appendChild(cellKeyPoints);

            const cellFilename = document.createElement('td');
            cellFilename.textContent = keyPoints.filename;
            row.appendChild(cellFilename);

            // æ·»åŠ è¡Œç‚¹å‡»äº‹ä»¶
            row.addEventListener('click', function(e) {
                if (e.target.type !== 'checkbox') {
                    toggleRowSelection(this);
                }
            });

            // æ·»åŠ å¤é€‰æ¡†ç‚¹å‡»äº‹ä»¶
            checkbox.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleRowSelection(row);
            });

            // æ·»åŠ å³é”®å¤åˆ¶äº‹ä»¶
            row.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                copyRowContent(row);
            });

            tableBody.appendChild(row);
            
            // ç»Ÿè®¡è€ƒç‚¹
            countPoints(keyPoints.points);
        }
    }
    
    updateRowCount();
    reapplyRowColors();
}

// ç»Ÿè®¡è€ƒç‚¹å‡½æ•°
function countPoints(points) {
    const difficultyKeywords = ['éš¾åº¦è¶…ä½', 'éš¾åº¦ä½', 'éš¾åº¦ä¸­ä½', 'éš¾åº¦ä¸­ç­‰', 'éš¾åº¦ä¸­é«˜', 'éš¾åº¦é«˜', 'éš¾åº¦è¶…é«˜'];
    const typeKeywords = ['é€‰æ‹©', 'å¡«ç©º', 'è§£ç­”'];
    const subjectKeywords = ['é«˜æ•°', 'çº¿ä»£', 'æ¦‚è®º'];
    
    points.forEach(point => {
        if (difficultyKeywords.includes(point)) {
            // ç»Ÿè®¡éš¾åº¦
            if (difficultyCounts[point]) {
                difficultyCounts[point]++;
            } else {
                difficultyCounts[point] = 1;
            }
        } else if (typeKeywords.includes(point)) {
            // ç»Ÿè®¡é¢˜å‹
            if (typeCounts[point]) {
                typeCounts[point]++;
            } else {
                typeCounts[point] = 1;
            }
        } else if (subjectKeywords.includes(point)) {
            // ç»Ÿè®¡ç§‘ç›®
            if (subjectCounts[point]) {
                subjectCounts[point]++;
            } else {
                subjectCounts[point] = 1;
            }
        } else {
            // ç»Ÿè®¡å…¶ä»–è€ƒç‚¹
            if (pointCounts[point]) {
                pointCounts[point]++;
            } else {
                pointCounts[point] = 1;
            }
        }
    });
}

function updateRowCount() {
    const totalRows = tableBody.rows.length;
    const visibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(row => row.style.display !== 'none').length;
    rowCountContainer.textContent = `æ˜¾ç¤º: ${visibleRows} / ${totalRows}`;
}

// åˆ‡æ¢è¡Œé€‰æ‹©çŠ¶æ€
function toggleRowSelection(row) {
    const title = row.dataset.title;
    if (selectedRows.has(title)) {
        selectedRows.delete(title);
        row.classList.remove('row-selected');
        const checkbox = row.querySelector('input[type="checkbox"]');
        if (checkbox) checkbox.checked = false;
    } else {
        selectedRows.add(title);
        row.classList.add('row-selected');
        const checkbox = row.querySelector('input[type="checkbox"]');
        if (checkbox) checkbox.checked = true;
    }
    updateSelectAllCheckbox();
}

// æ›´æ–°å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
function updateSelectAllCheckbox() {
    const visibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(row => 
        row.style.display !== 'none' && row.dataset.title
    );
    const selectedVisibleRows = visibleRows.filter(row => 
        selectedRows.has(row.dataset.title)
    );
    
    if (visibleRows.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedVisibleRows.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedVisibleRows.length === visibleRows.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    }
    
    // æ›´æ–°æ‰¹é‡å¤åˆ¶æŒ‰é’®çŠ¶æ€
    updateBatchCopyButton();
}

// æ›´æ–°æ‰¹é‡å¤åˆ¶æŒ‰é’®çŠ¶æ€
function updateBatchCopyButton() {
    if (selectedRows.size > 0) {
        batchCopyBtn.disabled = false;
        batchCopyBtn.textContent = `æ‰¹é‡å¤åˆ¶ (${selectedRows.size})`;
    } else {
        batchCopyBtn.disabled = true;
        batchCopyBtn.textContent = 'æ‰¹é‡å¤åˆ¶';
    }
}

// å…¨é€‰/å–æ¶ˆå…¨é€‰
function toggleSelectAll() {
    const visibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(row => 
        row.style.display !== 'none' && row.dataset.title
    );
    
    if (selectAllCheckbox.checked) {
        // å…¨é€‰
        visibleRows.forEach(row => {
            const title = row.dataset.title;
            if (!selectedRows.has(title)) {
                selectedRows.add(title);
                row.classList.add('row-selected');
                const checkbox = row.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = true;
            }
        });
    } else {
        // å–æ¶ˆå…¨é€‰
        visibleRows.forEach(row => {
            const title = row.dataset.title;
            selectedRows.delete(title);
            row.classList.remove('row-selected');
            const checkbox = row.querySelector('input[type="checkbox"]');
            if (checkbox) checkbox.checked = false;
        });
    }
    
    // æ‰‹åŠ¨æ›´æ–°æ‰¹é‡å¤åˆ¶æŒ‰é’®çŠ¶æ€
    updateBatchCopyButton();
}

function reapplyRowColors() {
    const allRows = tableBody.querySelectorAll('tr');
    allRows.forEach(row => {
        row.classList.remove('row-odd', 'row-even');
    });

    const visibleRows = Array.from(allRows).filter(row => row.style.display !== 'none');
    visibleRows.forEach((row, index) => {
        // å¦‚æœè¡Œè¢«é€‰ä¸­ï¼Œä¸åº”ç”¨å¥‡å¶è¡Œé¢œè‰²
        if (!selectedRows.has(row.dataset.title)) {
            if (index % 2 === 0) {
                row.classList.add('row-odd');
            } else {
                row.classList.add('row-even');
            }
        }
    });
    updateSelectAllCheckbox();
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// æ–‡ä»¶æ‹–æ‹½å¤„ç†
dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('dragover');
});

dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('dragover');
});

dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
        let processedFiles = 0;
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            if (file.type === 'text/markdown' || file.name.endsWith('.md')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    console.log('æ–‡ä»¶å†…å®¹å‰100å­—ç¬¦:', content.substring(0, 100));
                    console.log('æ–‡ä»¶æ€»é•¿åº¦:', content.length);
                    const filename = file.name.replace(/\.md$/i, ''); // å»æ‰.mdåç¼€
                    
                    // å­˜å‚¨æ¯ä¸ªæ–‡ä»¶çš„æ•°æ®
                    fileData[filename] = parseMarkdown(content, filename);
                    activeFiles.add(filename); // é»˜è®¤æ¿€æ´»æ–°æ·»åŠ çš„æ–‡ä»¶
                    // è®°å½•æ–‡ä»¶é¡ºåº
                    if (!fileOrder.includes(filename)) {
                        fileOrder.push(filename);
                    }
                    
                    processedFiles++;
                    
                    // å½“æ‰€æœ‰æ–‡ä»¶éƒ½å¤„ç†å®Œæˆåæ›´æ–°ç•Œé¢
                    if (processedFiles === files.length) {
                        updateFileTags();
                        updateTable();
                        updateFileInfo(); // ç¡®ä¿æ–‡ä»¶ä¿¡æ¯æ›´æ–°
                    }
                };
                reader.readAsText(file);
            } else {
                processedFiles++;
                if (processedFiles === files.length) {
                    updateFileTags();
                    updateTable();
                    updateFileInfo(); // ç¡®ä¿æ–‡ä»¶ä¿¡æ¯æ›´æ–°
                }
            }
        }
    }
});

// æœç´¢åŠŸèƒ½
searchInput.addEventListener('input', function () {
    const queryValue = this.value.trim();
    clearBtn.style.display = queryValue ? 'block' : 'none';

    const queries = queryValue.split(/[,ï¼Œ]/).map(q => q.trim()).filter(q => q);
    
    if (queries.length === 0) {
        // æ˜¾ç¤ºæ‰€æœ‰è¡Œï¼Œæ¢å¤åŸå§‹åºå·
        const rows = tableBody.querySelectorAll('tr');
        rows.forEach((row, index) => {
            row.style.display = '';
            const title = row.dataset.title;
            if (data[title]) {
                const keyPointsCell = row.cells[2];
                keyPointsCell.innerHTML = data[title].points.join('ï¼Œ');
                // æ¢å¤åŸå§‹åºå·
                const numberSpan = row.querySelector('.index-checkbox span');
                if (numberSpan) {
                    numberSpan.textContent = index + 1;
                }
            }
        });
        updateRowCount();
        reapplyRowColors();
        return;
    }

    // æ”¶é›†åŒ¹é…çš„è¡Œæ•°æ®ç”¨äºæ’åº
    const matchedRows = [];
    const rows = tableBody.querySelectorAll('tr');

    rows.forEach(row => {
        const title = row.dataset.title;
        if (!data[title]) return;
        
        const keyPointsString = data[title].points.join('ï¼Œ');
        const keyPointsStringLower = keyPointsString.toLowerCase();
        const titleLower = title.toLowerCase();
        const fileNameLower = row.cells[3].textContent.toLowerCase();

        let isMatch = false;
        let exactMatchCount = 0;
        let partialMatchCount = 0;
        let titleExactMatch = false;
        let fileNameExactMatch = false;
        let titleMatch = false;
        let fileNameMatch = false;
        
        if (searchMode === 'exact') {
            // ç²¾ç¡®åŒ¹é…ï¼ˆä¸”ï¼‰ï¼šæ‰€æœ‰å…³é”®è¯éƒ½å¿…é¡»å®Œå…¨åŒ¹é…è€ƒç‚¹
            isMatch = queries.every(query => 
                data[title].points.some(point => point === query)
            );
            if (isMatch) {
                exactMatchCount = queries.filter(query => 
                    data[title].points.includes(query)
                ).length;
            }
        } else if (searchMode === 'partialAnd') {
            // éƒ¨åˆ†åŒ¹é…ï¼ˆä¸”ï¼‰ï¼šæ‰€æœ‰å…³é”®è¯éƒ½å¿…é¡»åŒ…å«åœ¨è€ƒç‚¹ä¸­
            isMatch = queries.every(query => 
                data[title].points.some(point => point.includes(query))
            );
            if (isMatch) {
                partialMatchCount = queries.filter(query => 
                    data[title].points.some(point => point.includes(query))
                ).length;
            }
        } else {
            // éƒ¨åˆ†åŒ¹é…ï¼ˆæˆ–ï¼‰ï¼šä»»ä¸€å…³é”®è¯åŒ…å«åœ¨è€ƒç‚¹ä¸­å³å¯
            titleMatch = queries.some(query => titleLower.includes(query.toLowerCase()));
            fileNameMatch = queries.some(query => fileNameLower.includes(query.toLowerCase()));
            const topicMatch = queries.some(query => 
                data[title].points.some(point => point.includes(query))
            );
            isMatch = topicMatch || titleMatch || fileNameMatch;
            
            if (isMatch) {
                exactMatchCount = queries.filter(query => 
                    data[title].points.includes(query)
                ).length;
                partialMatchCount = queries.filter(query => 
                    data[title].points.some(point => point.includes(query) && !data[title].points.includes(query))
                ).length;
            }
        }

        titleExactMatch = queries.includes(title);
        fileNameExactMatch = queries.includes(row.cells[3].textContent);

        if (isMatch) {
            matchedRows.push({
                row: row,
                title: title,
                exactMatchCount: exactMatchCount,
                partialMatchCount: partialMatchCount,
                titleExactMatch: titleExactMatch,
                fileNameExactMatch: fileNameExactMatch,
                titleMatch: titleMatch,
                fileNameMatch: fileNameMatch,
                queries: queries
            });
        } else {
            row.style.display = 'none';
        }
    });

    // å¯¹åŒ¹é…çš„è¡Œè¿›è¡Œæ’åº
    matchedRows.sort((a, b) => {
        if (a.exactMatchCount !== b.exactMatchCount) return b.exactMatchCount - a.exactMatchCount;
        if (a.partialMatchCount !== b.partialMatchCount) return b.partialMatchCount - a.partialMatchCount;
        if (a.titleExactMatch !== b.titleExactMatch) return a.titleExactMatch ? -1 : 1;
        if (a.fileNameExactMatch !== b.fileNameExactMatch) return a.fileNameExactMatch ? -1 : 1;
        if (a.titleMatch !== b.titleMatch) return a.titleMatch ? -1 : 1;
        if (a.fileNameMatch !== b.fileNameMatch) return a.fileNameMatch ? -1 : 1;
        return 0;
    });

    // é‡æ–°æ˜¾ç¤ºæ’åºåçš„è¡Œå¹¶æ›´æ–°åºå·
    matchedRows.forEach((item, index) => {
        const row = item.row;
        row.style.display = '';
        
        // æ›´æ–°åºå·
        const numberSpan = row.querySelector('.index-checkbox span');
        if (numberSpan) {
            numberSpan.textContent = index + 1;
        }

        // é«˜äº®æ˜¾ç¤ºåŒ¹é…çš„å†…å®¹
        const originalPoints = data[item.title].points;
        const searchRegex = new RegExp(item.queries.map(q => escapeRegExp(q)).join('|'), 'gi');
        
        const orderedMatchedPoints = [];
        const addedPoints = new Set();

        item.queries.forEach(query => {
                    originalPoints.forEach(point => {
                        const isMatchPoint = (searchMode === 'exact')
                            ? (point === query)
                            : point.toLowerCase().includes(query.toLowerCase());
                        if (isMatchPoint && !addedPoints.has(point)) {
                            orderedMatchedPoints.push(point);
                            addedPoints.add(point);
                        }
                    });
                });

                const unmatchedPoints = originalPoints.filter(point => !addedPoints.has(point));
                const reorderedPoints = [...orderedMatchedPoints, ...unmatchedPoints];

                if (searchMode === 'exact') {
                    const highlightedPoints = reorderedPoints.map(p =>
                        item.queries.includes(p)
                            ? `<strong style="color: red;">${p}</strong>`
                            : p
                    );
                    row.cells[2].innerHTML = highlightedPoints.join('ï¼Œ');
                } else {
                    const reorderedKeyPointsString = reorderedPoints.join('ï¼Œ');
                    const highlightedText = reorderedKeyPointsString.replace(searchRegex, match => `<strong style="color: red;">${match}</strong>`);
                    row.cells[2].innerHTML = highlightedText;
                }
            });

    updateRowCount();
    reapplyRowColors();
});

clearBtn.addEventListener('click', function() {
    searchInput.value = '';
    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
});

const scrollToTopBtn = document.getElementById('scrollToTopBtn');

window.onscroll = function() {
    if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
        scrollToTopBtn.style.display = "block";
    } else {
        scrollToTopBtn.style.display = "none";
    }
};

scrollToTopBtn.addEventListener('click', function() {
    window.scrollTo({top: 0, behavior: 'smooth'});
});

// å¤åˆ¶è¡Œå†…å®¹
function copyRowContent(row) {
    const title = row.dataset.title;
    const filename = row.cells[3].textContent; // æ–‡ä»¶ååœ¨ç¬¬4åˆ—
    
    const obsidianLink = `![[${filename}#${title}|${title}]]`;
    
    // å¤åˆ¶åˆ°å‰ªè´´æ¿
    navigator.clipboard.writeText(obsidianLink).then(() => {
        showCopyVisualFeedback(row);
    }).catch(err => {
        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•å¤åˆ¶
        const textArea = document.createElement('textarea');
        textArea.value = obsidianLink;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showCopyVisualFeedback(row);
    });
}

// æ˜¾ç¤ºå¤åˆ¶æˆåŠŸçš„è§†è§‰åé¦ˆ
function showCopyVisualFeedback(row) {
    // æ·»åŠ å¤åˆ¶æˆåŠŸçš„æ ·å¼
    row.classList.add('row-copied');
    
    // 3ç§’åç§»é™¤æ ·å¼
    setTimeout(() => {
        row.classList.remove('row-copied');
    }, 3000);
}

// æ‰¹é‡å¤åˆ¶é€‰ä¸­è¡Œ
function batchCopySelectedRows() {
    if (selectedRows.size === 0) return;
    
    const selectedTitles = Array.from(selectedRows);
    const copyContent = selectedTitles.map(title => {
        // æ‰¾åˆ°å¯¹åº”çš„è¡Œæ•°æ®
        for (const filename in fileData) {
            if (fileData[filename][title]) {
                return `![[${filename}#${title}|${title}]]`;
            }
        }
        return null;
    }).filter(item => item !== null).join('\n\n');
    
    // å¤åˆ¶åˆ°å‰ªè´´æ¿
    navigator.clipboard.writeText(copyContent).then(() => {
        showBatchCopyVisualFeedback();
    }).catch(err => {
        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•å¤åˆ¶
        const textArea = document.createElement('textarea');
        textArea.value = copyContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showBatchCopyVisualFeedback();
    });
}

// æ˜¾ç¤ºæ‰¹é‡å¤åˆ¶æˆåŠŸçš„è§†è§‰åé¦ˆ
function showBatchCopyVisualFeedback() {
    // ä¸ºæ‰€æœ‰é€‰ä¸­çš„è¡Œæ·»åŠ å¤åˆ¶æˆåŠŸæ ·å¼
    const selectedVisibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(row => 
        selectedRows.has(row.dataset.title)
    );
    
    selectedVisibleRows.forEach(row => {
        row.classList.add('row-copied');
    });
    
    // 3ç§’åç§»é™¤æ ·å¼
    setTimeout(() => {
        selectedVisibleRows.forEach(row => {
            row.classList.remove('row-copied');
        });
    }, 3000);
}

// å…¨é€‰å¤é€‰æ¡†äº‹ä»¶ç›‘å¬
selectAllCheckbox.addEventListener('change', function() {
    toggleSelectAll();
});

// æ‰¹é‡å¤åˆ¶æŒ‰é’®äº‹ä»¶ç›‘å¬
batchCopyBtn.addEventListener('click', function() {
    batchCopySelectedRows();
});

// ç”Ÿæˆå›¾è¡¨é¢œè‰²
function generateColors(count) {
    const colors = [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
        '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384',
        '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'
    ];
    const result = [];
    for (let i = 0; i < count; i++) {
        result.push(colors[i % colors.length]);
    }
    return result;
}

// è·å–å›¾è¡¨é…ç½®
function getChartConfig(labels, data, chartType) {
    const colors = generateColors(labels.length);
    const baseConfig = {
        data: {
            labels: labels,
            datasets: [{
                label: 'è®¡æ•°',
                data: data,
                backgroundColor: colors.map(color => color + '80'), // æ·»åŠ é€æ˜åº¦
                borderColor: colors,
                borderWidth: 2
            }]
        },
        options: {
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: chartType === 'pie' || chartType === 'doughnut',
                    position: 'right',
                    labels: {
                        font: { size: 14 }
                    }
                },
                title: {
                    display: true,
                    text: 'è€ƒç‚¹åˆ†æå›¾',
                    font: { size: 24 }
                },
                datalabels: {
                    display: chartType !== 'radar',
                    anchor: chartType === 'bar' ? 'end' : 'center',
                    align: chartType === 'bar' ? 'end' : 'center',
                    formatter: (value) => value,
                    font: { size: 14 },
                    color: '#333'
                }
            },
            hover: {
                mode: 'nearest',
                intersect: true,
                animationDuration: 400
            }
        },
        plugins: [ChartDataLabels]
    };

    // æ ¹æ®å›¾è¡¨ç±»å‹è°ƒæ•´é…ç½®
    switch (chartType) {
        case 'bar':
            const maxValue = Math.max(...data);
            const suggestedMax = Math.ceil(maxValue * 1.1); // æ¯”æœ€å¤§å€¼é«˜10%ï¼Œå‘ä¸Šå–æ•´
            baseConfig.options.scales = {
                y: {
                    beginAtZero: true,
                    suggestedMax: suggestedMax,
                    ticks: {
                        font: { size: 14 },
                        stepSize: 1,
                        callback: function (value) {
                            return Number.isInteger(value) ? value : null;
                        }
                    }
                },
                x: {
                    ticks: { font: { size: 12 } }
                }
            };
            break;
        case 'line':
            const lineMaxValue = Math.max(...data);
            const lineSuggestedMax = Math.ceil(lineMaxValue * 1.1); // æ¯”æœ€å¤§å€¼é«˜10%ï¼Œå‘ä¸Šå–æ•´
            baseConfig.options.scales = {
                y: {
                    beginAtZero: true,
                    suggestedMax: lineSuggestedMax,
                    ticks: {
                        font: { size: 14 },
                        stepSize: 1
                    }
                },
                x: {
                    ticks: { font: { size: 12 } }
                }
            };
            baseConfig.data.datasets[0].fill = false;
            baseConfig.data.datasets[0].tension = 0.4;
            break;
        case 'radar':
            baseConfig.options.scales = {
                r: {
                    beginAtZero: true,
                    ticks: {
                        font: { size: 12 },
                        stepSize: 1
                    }
                }
            };
            baseConfig.data.datasets[0].fill = true;
            baseConfig.data.datasets[0].backgroundColor = colors[0] + '40';
            break;
        case 'pie':
        case 'doughnut':
            baseConfig.options.plugins.datalabels.color = '#fff';
            baseConfig.options.plugins.datalabels.font.weight = 'bold';
            break;
    }

    return baseConfig;
}

// å›¾è¡¨ç›¸å…³å‡½æ•°
function updateChart() {
    const chartCanvas = document.getElementById('chart');
    const sortedCounts = Object.entries(pointCounts).sort((a, b) => b[1] - a[1]);

    // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œåˆ™ä¸æ›´æ–°å›¾è¡¨
    if (sortedCounts.length === 0) {
        if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
        }
        document.getElementById('minRangeValue').textContent = '0';
        document.getElementById('maxRangeValue').textContent = '0';
        document.getElementById('minRange').value = 0;
        document.getElementById('maxRange').value = 0;
        document.getElementById('minRange').max = 0;
        document.getElementById('maxRange').max = 0;
        return;
    }

    const labels = sortedCounts.map(([point, count]) => point);
    const data = sortedCounts.map(([point, count]) => count);

    const maxDataValue = Math.max(...data, 1);
    const minDataValue = Math.min(...data, 0);

    // åŠ¨æ€è®¡ç®—åˆå§‹æœ€å°å€¼
    const maxInitialBars = 50;
    let initialMinCount = minDataValue;

    if (sortedCounts.length > maxInitialBars) {
        initialMinCount = sortedCounts[maxInitialBars - 1][1];
    }
    initialMinCount = Math.min(initialMinCount, maxDataValue);

    // æ›´æ–°æ»‘åŠ¨æ¡çš„æœ€å¤§å€¼å’Œå½“å‰å€¼
    const minRangeInput = document.getElementById('minRange');
    const maxRangeInput = document.getElementById('maxRange');

    minRangeInput.max = maxDataValue;
    maxRangeInput.max = maxDataValue;

    minRangeInput.value = initialMinCount;
    maxRangeInput.value = maxDataValue;

    // æ›´æ–°æ˜¾ç¤ºçš„æ•°å€¼
    document.getElementById('minRangeValue').textContent = minRangeInput.value;
    document.getElementById('maxRangeValue').textContent = maxRangeInput.value;

    // é”€æ¯ç°æœ‰çš„å›¾è¡¨å®ä¾‹
    if (chartInstance) {
        chartInstance.destroy();
    }

    // æ ¹æ®åˆå§‹æ»‘åŠ¨æ¡å€¼è¿‡æ»¤æ•°æ®ä»¥ä¾›é¦–æ¬¡æ¸²æŸ“
    const initialFilteredData = sortedCounts
        .filter(([point, count]) => count >= initialMinCount && count <= maxDataValue)
        .sort((a, b) => b[1] - a[1]);

    const initialLabels = initialFilteredData.map(([point, count]) => point);
    const initialData = initialFilteredData.map(([point, count]) => count);

    // åˆ›å»ºæ–°çš„å›¾è¡¨å®ä¾‹
    const config = getChartConfig(initialLabels, initialData, currentChartType);
    config.type = currentChartType;
    chartInstance = new Chart(chartCanvas, config);

    // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤æ·»åŠ 
    minRangeInput.removeEventListener('input', filterChart);
    maxRangeInput.removeEventListener('input', filterChart);
    // æ·»åŠ æ»‘åŠ¨æ¡äº‹ä»¶ç›‘å¬
    minRangeInput.addEventListener('input', filterChart);
    maxRangeInput.addEventListener('input', filterChart);
}

function filterChart() {
    const minRangeInput = document.getElementById('minRange');
    const maxRangeInput = document.getElementById('maxRange');

    let minRange = parseInt(minRangeInput.value, 10);
    let maxRange = parseInt(maxRangeInput.value, 10);

    // ç¡®ä¿æœ€å°å€¼ä¸å¤§äºæœ€å¤§å€¼
    if (minRange > maxRange) {
        minRange = maxRange;
        minRangeInput.value = minRange;
    }

    const filteredData = Object.entries(pointCounts)
        .filter(([point, count]) => count >= minRange && count <= maxRange)
        .sort((a, b) => b[1] - a[1]);

    const labels = filteredData.map(([point, count]) => point);
    const data = filteredData.map(([point, count]) => count);

    if (chartInstance) {
        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = data;
        chartInstance.update();
    }

    // æ›´æ–°æ»‘åŠ¨æ¡æ˜¾ç¤ºçš„æ•°å€¼
    document.getElementById('minRangeValue').textContent = minRange;
    document.getElementById('maxRangeValue').textContent = maxRange;
}

// åˆ‡æ¢å›¾è¡¨ç±»å‹
function switchChartType(type) {
    currentChartType = type;
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.chart-type-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`[data-type="${type}"]`).classList.add('active');
    
    // é‡æ–°ç”Ÿæˆå›¾è¡¨
    updateChart();
}

// æœç´¢æ¨¡å¼åˆ‡æ¢å‡½æ•°
function toggleSearchMode(mode) {
    if (searchMode === mode) return;

    if (searchMode && buttons[searchMode]) {
        buttons[searchMode].classList.remove('selected');
    }
    searchMode = mode;
    if (buttons[searchMode]) {
        buttons[searchMode].classList.add('selected');
    }
    
    // é‡æ–°æ‰§è¡Œæœç´¢
    const event = new Event('input', { bubbles: true });
    searchInput.dispatchEvent(event);
}

// äº‹ä»¶ç›‘å¬å™¨
showChartButton.addEventListener('click', () => {
    overlay.style.display = 'block';
    chartContainer.style.display = 'block';
    updateChart();
});

closeChart.addEventListener('click', () => {
    overlay.style.display = 'none';
    chartContainer.style.display = 'none';
});

// æ·»åŠ å³é”®å…³é—­å›¾è¡¨åŠŸèƒ½
chartContainer.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    overlay.style.display = 'none';
    chartContainer.style.display = 'none';
});

// å›¾è¡¨ç±»å‹åˆ‡æ¢äº‹ä»¶ç›‘å¬
document.querySelectorAll('.chart-type-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        switchChartType(type);
    });
});

// ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
function toggleTheme() {
    isDarkMode = !isDarkMode;
    const body = document.body;
    
    if (isDarkMode) {
        body.classList.add('dark-mode');
        themeToggleBtn.textContent = 'â˜€ï¸ æµ…è‰²æ¨¡å¼';
        localStorage.setItem('theme', 'dark');
    } else {
        body.classList.remove('dark-mode');
        themeToggleBtn.textContent = 'ğŸŒ™ æ·±è‰²æ¨¡å¼';
        localStorage.setItem('theme', 'light');
    }
}

// åˆå§‹åŒ–ä¸»é¢˜
function initTheme() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
        isDarkMode = true;
        document.body.classList.add('dark-mode');
        themeToggleBtn.textContent = 'â˜€ï¸ æµ…è‰²æ¨¡å¼';
    }
}

// åˆå§‹åŒ–æŒ‰é’®å’Œæœç´¢æ¨¡å¼
document.addEventListener('DOMContentLoaded', () => {
    buttons = {
        partialOr: document.getElementById('partialOrMatchButton'),
        partialAnd: document.getElementById('partialAndMatchButton'),
        exact: document.getElementById('exactMatchButton')
    };

    // è®¾ç½®é»˜è®¤æ¨¡å¼
    buttons.partialOr.classList.add('selected');
    
    // åˆå§‹åŒ–ä¸»é¢˜
    initTheme();
});

// ç”Ÿæˆç»Ÿè®¡é¢æ¿å†…å®¹
function generateStatsContent() {
    const totalQuestions = Object.keys(data).length;
    const totalFiles = activeFiles.size;
    
    // è®¡ç®—å„ç§ç»Ÿè®¡
    const totalPoints = Object.values(pointCounts).reduce((sum, count) => sum + count, 0);
    const totalDifficulties = Object.values(difficultyCounts).reduce((sum, count) => sum + count, 0);
    const totalTypes = Object.values(typeCounts).reduce((sum, count) => sum + count, 0);
    const totalSubjects = Object.values(subjectCounts).reduce((sum, count) => sum + count, 0);
    
    let statsHTML = `
        <div class="stats-section">
            <h3>ğŸ“ˆ æ€»ä½“ç»Ÿè®¡</h3>
            <div class="stats-grid">
                <div class="stats-card">
                    <div class="number">${totalQuestions}</div>
                    <div class="label">æ€»é¢˜ç›®æ•°</div>
                </div>
                <div class="stats-card">
                    <div class="number">${totalFiles}</div>
                    <div class="label">æ¿€æ´»æ–‡ä»¶æ•°</div>
                </div>
                <div class="stats-card">
                    <div class="number">${Object.keys(pointCounts).length}</div>
                    <div class="label">è€ƒç‚¹ç§ç±»</div>
                </div>
                <div class="stats-card">
                    <div class="number">${totalPoints}</div>
                    <div class="label">è€ƒç‚¹æ€»æ•°</div>
                </div>
            </div>
        </div>
    `;
    
    // éš¾åº¦åˆ†å¸ƒ
    if (Object.keys(difficultyCounts).length > 0) {
        const difficultyOrder = ['éš¾åº¦è¶…ä½', 'éš¾åº¦ä½', 'éš¾åº¦ä¸­ä½', 'éš¾åº¦ä¸­ç­‰', 'éš¾åº¦ä¸­é«˜', 'éš¾åº¦é«˜', 'éš¾åº¦è¶…é«˜'];
        const sortedDifficulties = difficultyOrder.filter(d => difficultyCounts[d]).map(d => ({
            name: d,
            count: difficultyCounts[d]
        }));
        
        statsHTML += `
            <div class="stats-section">
                <h3>ğŸ“Š éš¾åº¦åˆ†å¸ƒ</h3>
                <div class="stats-list">
                    ${sortedDifficulties.map(item => `
                        <div class="stats-item">
                            <span class="name">${item.name}</span>
                            <span class="count">${item.count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    // é¢˜å‹åˆ†å¸ƒ
    if (Object.keys(typeCounts).length > 0) {
        const typeOrder = ['é€‰æ‹©', 'å¡«ç©º', 'è§£ç­”'];
        const sortedTypes = typeOrder.filter(t => typeCounts[t]).map(t => ({
            name: t,
            count: typeCounts[t]
        }));
        
        statsHTML += `
            <div class="stats-section">
                <h3>ğŸ“ é¢˜å‹åˆ†å¸ƒ</h3>
                <div class="stats-list">
                    ${sortedTypes.map(item => `
                        <div class="stats-item">
                            <span class="name">${item.name}</span>
                            <span class="count">${item.count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    // ç§‘ç›®åˆ†å¸ƒ
    if (Object.keys(subjectCounts).length > 0) {
        const subjectOrder = ['é«˜æ•°', 'çº¿ä»£', 'æ¦‚è®º'];
        const sortedSubjects = subjectOrder.filter(s => subjectCounts[s]).map(s => ({
            name: s,
            count: subjectCounts[s]
        }));
        
        statsHTML += `
            <div class="stats-section">
                <h3>ğŸ“š ç§‘ç›®åˆ†å¸ƒ</h3>
                <div class="stats-list">
                    ${sortedSubjects.map(item => `
                        <div class="stats-item">
                            <span class="name">${item.name}</span>
                            <span class="count">${item.count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    // è€ƒç‚¹åˆ†å¸ƒï¼ˆå‰20ä¸ªï¼‰
    if (Object.keys(pointCounts).length > 0) {
        const sortedPoints = Object.entries(pointCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20);
        
        statsHTML += `
            <div class="stats-section">
                <h3>ğŸ¯ è€ƒç‚¹åˆ†å¸ƒ (å‰20ä¸ª)</h3>
                <div class="stats-list">
                    ${sortedPoints.map(([point, count]) => `
                        <div class="stats-item">
                            <span class="name">${point}</span>
                            <span class="count">${count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    // æ–‡ä»¶åˆ†å¸ƒ
    const fileStats = {};
    for (const filename of activeFiles) {
        if (fileData[filename]) {
            fileStats[filename] = Object.keys(fileData[filename]).length;
        }
    }
    
    if (Object.keys(fileStats).length > 0) {
        const sortedFiles = Object.entries(fileStats)
            .sort((a, b) => b[1] - a[1]);
        
        statsHTML += `
            <div class="stats-section">
                <h3>ğŸ“ æ–‡ä»¶åˆ†å¸ƒ</h3>
                <div class="stats-list">
                    ${sortedFiles.map(([filename, count]) => `
                        <div class="stats-item">
                            <span class="name">${filename}</span>
                            <span class="count">${count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    statsContent.innerHTML = statsHTML;
}

// æ˜¾ç¤ºç»Ÿè®¡é¢æ¿
function showStatsPanel() {
    generateStatsContent();
    overlay.style.display = 'block';
    statsContainer.style.display = 'block';
}

// éšè—ç»Ÿè®¡é¢æ¿
function hideStatsPanel() {
    overlay.style.display = 'none';
    statsContainer.style.display = 'none';
}

// ä¸»é¢˜åˆ‡æ¢æŒ‰é’®äº‹ä»¶ç›‘å¬
themeToggleBtn.addEventListener('click', toggleTheme);

// è®¡ç®—é¢˜ç›®ç›¸ä¼¼åº¦
function calculateSimilarity(sourcePoints, subQuestionPoints) {
    if (!sourcePoints || !subQuestionPoints || sourcePoints.length === 0 || subQuestionPoints.length === 0) {
        return 0;
    }
    
    // å°†è€ƒç‚¹è½¬æ¢ä¸ºSetä»¥ä¾¿è®¡ç®—äº¤é›†
    const sourceSet = new Set(sourcePoints);
    const subQuestionSet = new Set(subQuestionPoints);
    
    // è®¡ç®—äº¤é›†å¤§å°ï¼ˆå…±åŒè€ƒç‚¹æ•°ï¼‰
    const intersection = new Set([...sourceSet].filter(x => subQuestionSet.has(x)));
    const commonPointsCount = intersection.size;
    
    // æºé¢˜ç›®ä¸­çš„è€ƒç‚¹æ•°
    const sourcePointsCount = sourcePoints.length;
    
    // æ–°çš„ç›¸ä¼¼åº¦è®¡ç®—æ–¹å¼ï¼š(å­é¢˜ç›®ä¸­ä¸æºé¢˜ç›®ä¸­ç›¸åŒçš„è€ƒç‚¹æ•° / æºé¢˜ç›®ä¸­çš„è€ƒç‚¹æ•°) * 100%
    return sourcePointsCount > 0 ? commonPointsCount / sourcePointsCount : 0;
}

// ç”Ÿæˆç›¸ä¼¼é¢˜ç›®æ¨è
function generateRecommendations() {
    if (Object.keys(data).length === 0) {
        recommendContent.innerHTML = '<div class="no-recommendations">æš‚æ— æ•°æ®ï¼Œè¯·å…ˆåŠ è½½é¢˜ç›®</div>';
        return;
    }

    const recommendations = [];
    const titles = Object.keys(data);

    // ä¸ºæ¯ä¸ªé¢˜ç›®è®¡ç®—ç›¸ä¼¼åº¦
    for (let i = 0; i < titles.length; i++) {
        const currentTitle = titles[i];
        const currentPoints = data[currentTitle].points;
        const currentSimilarities = [];

        // ä¸å…¶ä»–é¢˜ç›®æ¯”è¾ƒ
        for (let j = 0; j < titles.length; j++) {
            if (i !== j) {
                const otherTitle = titles[j];
                const otherPoints = data[otherTitle].points;
                const similarity = calculateSimilarity(currentPoints, otherPoints);
                
                if (similarity > 0) {
                    currentSimilarities.push({
                        title: otherTitle,
                        points: otherPoints,
                        filename: data[otherTitle].filename,
                        similarity: similarity
                    });
                }
            }
        }

        // æŒ‰ç›¸ä¼¼åº¦æ’åºï¼Œåªä¿ç•™ç›¸ä¼¼åº¦è¶…è¿‡49%çš„é¢˜ç›®
        currentSimilarities.sort((a, b) => b.similarity - a.similarity);
        const topSimilar = currentSimilarities
            .filter(item => item.similarity > 0.49)
            .slice(0, 5);

        if (topSimilar.length > 0) {
            recommendations.push({
                sourceTitle: currentTitle,
                sourcePoints: currentPoints,
                sourceFilename: data[currentTitle].filename,
                similarItems: topSimilar
            });
        }
    }

    // ç”Ÿæˆæ¨èå†…å®¹HTML
    let recommendHTML = '<h2 style="text-align: center; margin-bottom: 30px; color: #333;">ğŸ¯ ç›¸ä¼¼é¢˜ç›®æ¨è</h2>';
    recommendHTML += '<div style="text-align: center; margin-bottom: 20px; color: #666; font-size: 14px;">ğŸ’¡ <span class="similarity-point">åŠ ç²—è€ƒç‚¹</span> è¡¨ç¤ºä¸æºé¢˜ç›®ç›¸åŒçš„è€ƒç‚¹ï¼ˆç›¸ä¼¼ä¾æ®ï¼‰</div>';
    
    if (recommendations.length === 0) {
        recommendHTML += '<div class="no-recommendations">æœªæ‰¾åˆ°ç›¸ä¼¼é¢˜ç›®</div>';
    } else {
        recommendations.forEach((rec, index) => {
            // ä¸ºæºé¢˜ç›®æ‰¾å‡ºæ‰€æœ‰ç›¸ä¼¼é¢˜ç›®çš„å…±åŒè€ƒç‚¹
            const allCommonPoints = new Set();
            rec.similarItems.forEach(item => {
                const sourceSet = new Set(rec.sourcePoints);
                const itemSet = new Set(item.points);
                const commonPoints = [...sourceSet].filter(point => itemSet.has(point));
                commonPoints.forEach(point => allCommonPoints.add(point));
            });
            
            // æ ¼å¼åŒ–æºé¢˜ç›®è€ƒç‚¹æ˜¾ç¤ºï¼Œå…±åŒè€ƒç‚¹åŠ ç²—
            const formattedSourcePoints = rec.sourcePoints.map(point => {
                if (allCommonPoints.has(point)) {
                    return `<span class="similarity-point">${point}</span>`;
                }
                return point;
            }).join('ï¼Œ');
            
            // å®šä¹‰èƒŒæ™¯é¢œè‰²æ•°ç»„ï¼Œå¾ªç¯ä½¿ç”¨
            const backgroundColors = ['#fff5f5', '#f0f8ff', '#fff8f0', '#f0fff0'];
            const backgroundColor = backgroundColors[index % backgroundColors.length];
            
            recommendHTML += `
                <div class="recommend-section" style="background-color: ${backgroundColor};">
                    <button class="section-batch-copy" onclick="batchCopySection(this)" title="å¤åˆ¶æœ¬é¢˜æ‰€æœ‰ç›¸ä¼¼é¢˜ç›®">æ‰¹é‡å¤åˆ¶</button>
                    <h3>ğŸ“– ${rec.sourceTitle}</h3>
                    <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                        <strong>è€ƒç‚¹ï¼š</strong>${formattedSourcePoints}
                    </div>
                    <div style="margin-bottom: 10px; color: #999; font-size: 12px;">
                        <strong>æ¥æºï¼š</strong>${rec.sourceFilename}
                    </div>
                    <h4 style="margin: 15px 0 10px 0; color: #9C27B0;">ç›¸ä¼¼é¢˜ç›®ï¼š</h4>
            `;

            rec.similarItems.forEach((item, itemIndex) => {
                const similarityPercent = Math.round(item.similarity * 100);
                
                // æ‰¾å‡ºå…±åŒè€ƒç‚¹ï¼ˆç›¸ä¼¼ä¾æ®ï¼‰
                const sourceSet = new Set(rec.sourcePoints);
                const itemSet = new Set(item.points);
                const commonPoints = [...sourceSet].filter(point => itemSet.has(point));
                
                // æ ¼å¼åŒ–è€ƒç‚¹æ˜¾ç¤ºï¼Œå…±åŒè€ƒç‚¹åŠ ç²—
                const formattedPoints = item.points.map(point => {
                    if (commonPoints.includes(point)) {
                        return `<span class="similarity-point">${point}</span>`;
                    }
                    return point;
                }).join('ï¼Œ');
                
                recommendHTML += `
                    <div class="recommend-item" 
                         data-title="${item.title.replace(/"/g, '&quot;')}" 
                         data-filename="${item.filename.replace(/"/g, '&quot;')}" 
                         onclick="copyToClipboard('${item.title}', '${item.filename}', this)"
                         oncontextmenu="copyToClipboard('${item.title}', '${item.filename}', this); return false;">
                        <span class="item-number">${itemIndex + 1}</span>
                        <span class="similarity">${similarityPercent}%</span>
                        <div class="title">${item.title}</div>
                        <div class="points">${formattedPoints}</div>
                        <div class="filename">${item.filename}</div>
                    </div>
                `;
            });

            recommendHTML += '</div>';
        });
    }

    recommendContent.innerHTML = recommendHTML;
}

// å¤åˆ¶é¢˜ç›®åˆ°å‰ªè´´æ¿
function copyToClipboard(title, filename, element = null) {
    const obsidianLink = `![[${filename}#${title}|${title}]]`;
    
    navigator.clipboard.writeText(obsidianLink).then(() => {
        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
        const copySuccess = document.getElementById('copySuccess');
        copySuccess.style.display = 'block';
        setTimeout(() => {
            copySuccess.style.display = 'none';
        }, 2000);
        
        // å¦‚æœæä¾›äº†å…ƒç´ ï¼Œæ·»åŠ å¤åˆ¶æˆåŠŸçš„è§†è§‰åé¦ˆ
        if (element) {
            element.classList.add('item-copied');
            setTimeout(() => {
                element.classList.remove('item-copied');
            }, 3000);
        }
    }).catch(err => {
        // é™çº§æ–¹æ¡ˆ
        const textArea = document.createElement('textarea');
        textArea.value = obsidianLink;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        const copySuccess = document.getElementById('copySuccess');
        copySuccess.style.display = 'block';
        setTimeout(() => {
            copySuccess.style.display = 'none';
        }, 2000);
        
        // å¦‚æœæä¾›äº†å…ƒç´ ï¼Œæ·»åŠ å¤åˆ¶æˆåŠŸçš„è§†è§‰åé¦ˆ
        if (element) {
            element.classList.add('item-copied');
            setTimeout(() => {
                element.classList.remove('item-copied');
            }, 3000);
        }
    });
}

// æ‰¹é‡å¤åˆ¶æŸä¸ªé¢˜ç›®å®¹å™¨ä¸­çš„æ‰€æœ‰ç›¸ä¼¼é¢˜ç›®
function batchCopySection(buttonElement) {
    const sectionElement = buttonElement.closest('.recommend-section');
    if (!sectionElement) return;

    const itemElements = Array.from(sectionElement.querySelectorAll('.recommend-item'));
    if (itemElements.length === 0) return;

    // ç»„è£…éœ€è¦å¤åˆ¶çš„æ–‡æœ¬ï¼ˆä¸­é—´ç©ºä¸€è¡Œï¼‰
    const links = itemElements.map(itemEl => {
        const title = itemEl.getAttribute('data-title') || (itemEl.querySelector('.title')?.textContent || '').trim();
        const filename = itemEl.getAttribute('data-filename') || (itemEl.querySelector('.filename')?.textContent || '').trim();
        return `![[${filename}#${title}|${title}]]`;
    });
    const textToCopy = links.join('\n\n');

    // æ‰§è¡Œå¤åˆ¶å¹¶æä¾›è§†è§‰åé¦ˆ
    const showToast = () => {
        const copySuccess = document.getElementById('copySuccess');
        copySuccess.style.display = 'block';
        setTimeout(() => {
            copySuccess.style.display = 'none';
        }, 2000);
    };

    const addVisualFeedback = () => {
        itemElements.forEach(el => {
            el.classList.add('item-copied');
        });
        setTimeout(() => {
            itemElements.forEach(el => el.classList.remove('item-copied'));
        }, 3000);
    };

    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(textToCopy).then(() => {
            showToast();
            addVisualFeedback();
        }).catch(() => {
            // é™çº§æ–¹æ¡ˆ
            const textArea = document.createElement('textarea');
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showToast();
            addVisualFeedback();
        });
    } else {
        // é™çº§æ–¹æ¡ˆ
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showToast();
        addVisualFeedback();
    }
}

// æ˜¾ç¤ºæ¨èé¢æ¿
function showRecommendPanel() {
    generateRecommendations();
    overlay.style.display = 'block';
    recommendContainer.style.display = 'block';
}

// éšè—æ¨èé¢æ¿
function hideRecommendPanel() {
    overlay.style.display = 'none';
    recommendContainer.style.display = 'none';
}

// ç»Ÿè®¡é¢æ¿äº‹ä»¶ç›‘å¬
showStatsButton.addEventListener('click', showStatsPanel);
closeStats.addEventListener('click', hideStatsPanel);

// æ·»åŠ å³é”®å…³é—­ç»Ÿè®¡é¢æ¿åŠŸèƒ½
statsContainer.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    hideStatsPanel();
});

// æ¨èé¢æ¿äº‹ä»¶ç›‘å¬
showRecommendButton.addEventListener('click', showRecommendPanel);
closeRecommend.addEventListener('click', hideRecommendPanel);

// ç§»é™¤å³é”®å…³é—­æ¨èé¢æ¿åŠŸèƒ½ï¼Œæ”¹ä¸ºå¤åˆ¶åŠŸèƒ½

// åˆå§‹åŒ–
updateRowCount();
updateFileInfo();
updateBatchCopyButton();
    </script>

</body>

</html>
<!-- æˆ‘æ¥åˆ†æè¿™ä¸ªHTMLæ–‡ä»¶çš„åŠŸèƒ½ã€ä½¿ç”¨æ–¹æ³•å’Œåº”ç”¨åœºæ™¯ã€‚

Read file: è§£æä¸ºè¡¨æ ¼-24-é¢˜ç›®æ¨è.html
Read file: è§£æä¸ºè¡¨æ ¼-24-é¢˜ç›®æ¨è.html
Read file: è§£æä¸ºè¡¨æ ¼-24-é¢˜ç›®æ¨è.html
Read file: è§£æä¸ºè¡¨æ ¼-24-é¢˜ç›®æ¨è.html
åŸºäºå¯¹ä»£ç çš„è¯¦ç»†åˆ†æï¼Œæˆ‘æ¥ä¸ºæ‚¨å…¨é¢è§£æè¿™ä¸ªHTMLæ–‡ä»¶çš„åŠŸèƒ½ã€ä½¿ç”¨æ–¹æ³•å’Œåº”ç”¨åœºæ™¯ï¼š

## åŠŸèƒ½åˆ†æ

### æ ¸å¿ƒåŠŸèƒ½
è¿™æ˜¯ä¸€ä¸ª**é«˜çº§ç‰ˆMarkdownæ–‡ä»¶è§£æå’Œæ™ºèƒ½æ¨èå·¥å…·**ï¼Œåœ¨åŸºç¡€ç‰ˆæœ¬çš„åŸºç¡€ä¸Šå¢åŠ äº†**æ™ºèƒ½é¢˜ç›®æ¨èç³»ç»Ÿ**å’Œ**å¤šç»´åº¦ç»Ÿè®¡åˆ†æ**åŠŸèƒ½ï¼š

1. **Markdownæ–‡ä»¶è§£æ**
   - è§£æåŒ…å«å››çº§æ ‡é¢˜ï¼ˆ`####`ï¼‰å’Œè€ƒç‚¹ä¿¡æ¯çš„Markdownæ–‡ä»¶
   - æå–é¢˜ç›®åç§°å’Œå¯¹åº”çš„è€ƒç‚¹åˆ—è¡¨
   - æ”¯æŒå¤šæ–‡ä»¶åŒæ—¶å¤„ç†

2. **æ™ºèƒ½é¢˜ç›®æ¨èç³»ç»Ÿ**
   - åŸºäºè€ƒç‚¹ç›¸ä¼¼åº¦è®¡ç®—é¢˜ç›®é—´çš„å…³è”å…³ç³»
   - ä¸ºæ¯ä¸ªé¢˜ç›®æ¨èç›¸ä¼¼åº¦è¶…è¿‡50%çš„ç›¸å…³é¢˜ç›®
   - å¯è§†åŒ–æ˜¾ç¤ºç›¸ä¼¼ä¾æ®ï¼ˆå…±åŒè€ƒç‚¹é«˜äº®ï¼‰

3. **å¤šç»´åº¦ç»Ÿè®¡åˆ†æ**
   - æ€»ä½“ç»Ÿè®¡ï¼šé¢˜ç›®æ•°ã€æ–‡ä»¶æ•°ã€è€ƒç‚¹ç§ç±»ç­‰
   - éš¾åº¦åˆ†å¸ƒï¼šæŒ‰éš¾åº¦ç­‰çº§ç»Ÿè®¡é¢˜ç›®åˆ†å¸ƒ
   - é¢˜å‹åˆ†å¸ƒï¼šé€‰æ‹©é¢˜ã€å¡«ç©ºé¢˜ã€è§£ç­”é¢˜ç»Ÿè®¡
   - ç§‘ç›®åˆ†å¸ƒï¼šé«˜æ•°ã€çº¿ä»£ã€æ¦‚è®ºç­‰ç§‘ç›®ç»Ÿè®¡
   - è€ƒç‚¹åˆ†å¸ƒï¼šå‰20ä¸ªé«˜é¢‘è€ƒç‚¹ç»Ÿè®¡
   - æ–‡ä»¶åˆ†å¸ƒï¼šå„æ–‡ä»¶é¢˜ç›®æ•°é‡ç»Ÿè®¡

4. **å¢å¼ºçš„æ•°æ®å¯è§†åŒ–**
   - æ”¯æŒ5ç§å›¾è¡¨ç±»å‹ï¼šæ¡å½¢å›¾ã€é¥¼å›¾ã€ç¯å½¢å›¾ã€æŠ˜çº¿å›¾ã€é›·è¾¾å›¾
   - åŠ¨æ€èŒƒå›´ç­›é€‰ï¼ˆæ»‘åŠ¨æ¡æ§åˆ¶ï¼‰
   - å›¾è¡¨æ•°æ®æ ‡ç­¾æ˜¾ç¤º

5. **æ·±è‰²æ¨¡å¼æ”¯æŒ**
   - å®Œæ•´çš„æ·±è‰²ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
   - ä¸»é¢˜åå¥½æœ¬åœ°å­˜å‚¨

6. **ä¸‰ç§æœç´¢æ¨¡å¼**
   - éƒ¨åˆ†åŒ¹é…ï¼ˆæˆ–ï¼‰ï¼šä»»ä¸€å…³é”®è¯åŒ¹é…å³å¯
   - éƒ¨åˆ†åŒ¹é…ï¼ˆä¸”ï¼‰ï¼šæ‰€æœ‰å…³é”®è¯éƒ½å¿…é¡»åŒ¹é…
   - ç²¾ç¡®åŒ¹é…ï¼ˆä¸”ï¼‰ï¼šæ‰€æœ‰å…³é”®è¯éƒ½å¿…é¡»å®Œå…¨åŒ¹é…

7. **æ•°æ®ç®¡ç†åŠŸèƒ½**
   - æ‹–æ‹½ä¸Šä¼ å¤šä¸ªMarkdownæ–‡ä»¶
   - æ–‡ä»¶æ ‡ç­¾ç®¡ç†ï¼ˆæ¿€æ´»/åœç”¨/ç§»é™¤ï¼‰
   - æ‰¹é‡é€‰æ‹©å’Œå¤åˆ¶åŠŸèƒ½

## ä½¿ç”¨æ–¹æ³•

### 1. æ–‡ä»¶ä¸Šä¼ 
```
å°†Markdownæ–‡ä»¶æ‹–æ‹½åˆ°é¡µé¢é¡¶éƒ¨çš„è™šçº¿æ¡†ä¸­
æ”¯æŒåŒæ—¶æ‹–æ‹½å¤šä¸ª.mdæ–‡ä»¶
```

### 2. æ™ºèƒ½é¢˜ç›®æ¨è
```
ç‚¹å‡»å·¦ä¸‹è§’"ï¿½ï¿½ ç›¸ä¼¼é¢˜ç›®"æŒ‰é’®
ç³»ç»Ÿä¼šè‡ªåŠ¨åˆ†ææ‰€æœ‰é¢˜ç›®çš„è€ƒç‚¹ç›¸ä¼¼åº¦
ä¸ºæ¯ä¸ªé¢˜ç›®æ¨èç›¸ä¼¼åº¦è¶…è¿‡50%çš„ç›¸å…³é¢˜ç›®
ç‚¹å‡»æ¨èé¢˜ç›®å¯å¤åˆ¶Obsidiané“¾æ¥
```

### 3. ç»Ÿè®¡åˆ†æ
```
ç‚¹å‡»å·¦ä¸Šè§’"ğŸ“Š ç»Ÿè®¡é¢æ¿"æŒ‰é’®
æŸ¥çœ‹å¤šç»´åº¦ç»Ÿè®¡æ•°æ®ï¼š
- æ€»ä½“ç»Ÿè®¡ï¼šé¢˜ç›®æ€»æ•°ã€æ–‡ä»¶æ•°ç­‰
- éš¾åº¦åˆ†å¸ƒï¼šå„éš¾åº¦ç­‰çº§é¢˜ç›®æ•°é‡
- é¢˜å‹åˆ†å¸ƒï¼šé€‰æ‹©é¢˜ã€å¡«ç©ºé¢˜ç­‰åˆ†å¸ƒ
- ç§‘ç›®åˆ†å¸ƒï¼šé«˜æ•°ã€çº¿ä»£ç­‰ç§‘ç›®åˆ†å¸ƒ
- è€ƒç‚¹åˆ†å¸ƒï¼šå‰20ä¸ªé«˜é¢‘è€ƒç‚¹
- æ–‡ä»¶åˆ†å¸ƒï¼šå„æ–‡ä»¶é¢˜ç›®æ•°é‡
```

### 4. æ•°æ®å¯è§†åŒ–
```
ç‚¹å‡»å·¦ä¸‹è§’"ï¿½ï¿½ æ•°æ®å›¾è¡¨"æŒ‰é’®
é€‰æ‹©å›¾è¡¨ç±»å‹ï¼šæ¡å½¢å›¾ã€é¥¼å›¾ã€ç¯å½¢å›¾ã€æŠ˜çº¿å›¾ã€é›·è¾¾å›¾
ä½¿ç”¨æ»‘åŠ¨æ¡è°ƒæ•´æ˜¾ç¤ºèŒƒå›´
```

### 5. ä¸»é¢˜åˆ‡æ¢
```
ç‚¹å‡»å³ä¸Šè§’"ğŸŒ™ æ·±è‰²æ¨¡å¼"æŒ‰é’®
åœ¨æµ…è‰²å’Œæ·±è‰²ä¸»é¢˜é—´åˆ‡æ¢
ä¸»é¢˜åå¥½ä¼šè‡ªåŠ¨ä¿å­˜
```

### 6. æœç´¢å’Œç­›é€‰
```
åœ¨æœç´¢æ¡†ä¸­è¾“å…¥å…³é”®è¯ï¼Œç”¨é€—å·åˆ†éš”
é€‰æ‹©æœç´¢æ¨¡å¼ï¼šéƒ¨åˆ†åŒ¹é…ï¼ˆæˆ–/ä¸”ï¼‰ã€ç²¾ç¡®åŒ¹é…
æœç´¢ç»“æœä¼šæŒ‰ç›¸å…³åº¦æ’åº
```

### 7. æ•°æ®å¤åˆ¶
```
- å³é”®ç‚¹å‡»è¡Œå¤åˆ¶å•è¡Œæ•°æ®
- ä½¿ç”¨å³ä¸Šè§’"æ‰¹é‡å¤åˆ¶"æŒ‰é’®å¤åˆ¶é€‰ä¸­æ•°æ®
- åœ¨æ¨èé¢æ¿ä¸­ç‚¹å‡»é¢˜ç›®å¤åˆ¶å•ä¸ªæ¨è
- ä½¿ç”¨æ¨èé¢æ¿ä¸­çš„"æ‰¹é‡å¤åˆ¶"æŒ‰é’®å¤åˆ¶æŸé¢˜ç›®çš„æ‰€æœ‰ç›¸ä¼¼é¢˜ç›®
```

## æ™ºèƒ½æ¨èç®—æ³•è¯¦è§£

### ç›¸ä¼¼åº¦è®¡ç®—å…¬å¼
```
ç›¸ä¼¼åº¦ = (å…±åŒè€ƒç‚¹æ•° / æºé¢˜ç›®è€ƒç‚¹æ•°) Ã— 100%
```

### æ¨èè§„åˆ™
1. **ç›¸ä¼¼åº¦é˜ˆå€¼**ï¼šåªæ¨èç›¸ä¼¼åº¦è¶…è¿‡50%çš„é¢˜ç›®
2. **æ¨èæ•°é‡**ï¼šæ¯ä¸ªé¢˜ç›®æœ€å¤šæ¨è5ä¸ªç›¸ä¼¼é¢˜ç›®
3. **æ’åºæ–¹å¼**ï¼šæŒ‰ç›¸ä¼¼åº¦ä»é«˜åˆ°ä½æ’åº
4. **ç›¸ä¼¼ä¾æ®**ï¼šé«˜äº®æ˜¾ç¤ºå…±åŒè€ƒç‚¹ä½œä¸ºæ¨èä¾æ®

### æ¨èå±•ç¤º
- **æºé¢˜ç›®**ï¼šæ˜¾ç¤ºé¢˜ç›®åç§°ã€è€ƒç‚¹ã€æ¥æºæ–‡ä»¶
- **ç›¸ä¼¼é¢˜ç›®**ï¼šæ˜¾ç¤ºé¢˜ç›®åç§°ã€è€ƒç‚¹ã€ç›¸ä¼¼åº¦ç™¾åˆ†æ¯”
- **ç›¸ä¼¼ä¾æ®**ï¼šç”¨ç‰¹æ®Šé¢œè‰²é«˜äº®æ˜¾ç¤ºå…±åŒè€ƒç‚¹
- **æ‰¹é‡æ“ä½œ**ï¼šæ”¯æŒå¤åˆ¶æŸä¸ªé¢˜ç›®çš„æ‰€æœ‰ç›¸ä¼¼é¢˜ç›®

## åº”ç”¨åœºæ™¯

### 1. æ•™è‚²é¢†åŸŸ
- **æ™ºèƒ½é¢˜åº“æ¨è**ï¼šæ ¹æ®å­¦ç”Ÿå½“å‰å­¦ä¹ å†…å®¹æ¨èç›¸å…³é¢˜ç›®
- **çŸ¥è¯†ç‚¹å…³è”åˆ†æ**ï¼šå‘ç°ä¸åŒè€ƒç‚¹ä¹‹é—´çš„è”ç³»å’Œä¾èµ–å…³ç³»
- **ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„**ï¼šåŸºäºç›¸ä¼¼åº¦æ„å»ºä¸ªæ€§åŒ–å­¦ä¹ åºåˆ—
- **æ•™å­¦èµ„æºä¼˜åŒ–**ï¼šé¿å…é‡å¤å†…å®¹ï¼Œæé«˜èµ„æºåˆ©ç”¨æ•ˆç‡

### 2. è€ƒè¯•å‡†å¤‡
- **é‡ç‚¹çªç ´**ï¼šé€šè¿‡ç›¸ä¼¼é¢˜ç›®å‘ç°çŸ¥è¯†è–„å¼±ç¯èŠ‚
- **å¤ä¹ ç­–ç•¥åˆ¶å®š**ï¼šåŸºäºç›¸ä¼¼åº¦åˆ¶å®šç³»ç»ŸåŒ–å¤ä¹ è®¡åˆ’
- **æŸ¥æ¼è¡¥ç¼º**ï¼šç¡®ä¿æ‰€æœ‰ç›¸å…³çŸ¥è¯†ç‚¹éƒ½æœ‰è¦†ç›–
- **æ•ˆç‡æå‡**ï¼šé¿å…é‡å¤ç»ƒä¹ ç›¸åŒç±»å‹çš„é¢˜ç›®

### 3. å†…å®¹ç®¡ç†
- **çŸ¥è¯†å›¾è°±æ„å»º**ï¼šé€šè¿‡ç›¸ä¼¼åº¦å…³ç³»æ„å»ºçŸ¥è¯†ç½‘ç»œ
- **å†…å®¹å»é‡**ï¼šè¯†åˆ«å’Œåˆå¹¶ç›¸ä¼¼å†…å®¹
- **è´¨é‡è¯„ä¼°**ï¼šåˆ†æé¢˜ç›®è¦†ç›–çš„å…¨é¢æ€§å’Œå…³è”æ€§
- **èµ„æºæ•´åˆ**ï¼šä¼˜åŒ–é¢˜åº“ç»“æ„å’Œç»„ç»‡æ–¹å¼

### 4. ç ”ç©¶åˆ†æ
- **æ¨¡å¼è¯†åˆ«**ï¼šå‘ç°é¢˜ç›®è®¾è®¡ä¸­çš„æ¨¡å¼å’Œè§„å¾‹
- **å…³è”æŒ–æ˜**ï¼šåˆ†æçŸ¥è¯†ç‚¹ä¹‹é—´çš„éšå«å…³ç³»
- **è¶‹åŠ¿åˆ†æ**ï¼šç ”ç©¶è€ƒç‚¹ç»„åˆçš„å˜åŒ–è¶‹åŠ¿
- **å¯¹æ¯”ç ”ç©¶**ï¼šæ¯”è¾ƒä¸åŒé¢˜åº“çš„å†…å®¹å·®å¼‚

### 5. å›¢é˜Ÿåä½œ
- **åˆ†å·¥ä¼˜åŒ–**ï¼šæ ¹æ®ç›¸ä¼¼åº¦åˆç†åˆ†é…å·¥ä½œå†…å®¹
- **æ ‡å‡†ç»Ÿä¸€**ï¼šç¡®ä¿ç›¸ä¼¼é¢˜ç›®çš„è´¨é‡æ ‡å‡†ä¸€è‡´
- **èµ„æºå…±äº«**ï¼šæ™ºèƒ½æ¨èç›¸å…³å­¦ä¹ èµ„æº
- **è¿›åº¦è·Ÿè¸ª**ï¼šåŸºäºç›¸ä¼¼åº¦è·Ÿè¸ªå­¦ä¹ è¿›åº¦

### 6. è‡ªé€‚åº”å­¦ä¹ 
- **æ™ºèƒ½æ¨è**ï¼šæ ¹æ®å­¦ä¹ è¿›åº¦æ¨èä¸‹ä¸€é˜¶æ®µå†…å®¹
- **éš¾åº¦é€’è¿›**ï¼šåŸºäºç›¸ä¼¼åº¦æ„å»ºéš¾åº¦é€’è¿›åºåˆ—
- **ä¸ªæ€§åŒ–è·¯å¾„**ï¼šä¸ºä¸åŒå­¦ä¹ è€…å®šåˆ¶å­¦ä¹ è·¯å¾„
- **å­¦ä¹ æ•ˆæœè¯„ä¼°**ï¼šé€šè¿‡ç›¸ä¼¼é¢˜ç›®æµ‹è¯•å­¦ä¹ æ•ˆæœ

## æŠ€æœ¯ç‰¹ç‚¹

1. **æ™ºèƒ½ç®—æ³•**ï¼šåŸºäºè€ƒç‚¹ç›¸ä¼¼åº¦çš„æ™ºèƒ½æ¨èç®—æ³•
2. **å¤šç»´åº¦åˆ†æ**ï¼šå…¨é¢çš„ç»Ÿè®¡åˆ†æå’Œæ•°æ®å¯è§†åŒ–
3. **ç”¨æˆ·ä½“éªŒ**ï¼šæ·±è‰²æ¨¡å¼ã€å“åº”å¼è®¾è®¡ã€ç›´è§‚æ“ä½œ
4. **é«˜æ•ˆå¤„ç†**ï¼šæ”¯æŒå¤§é‡é¢˜ç›®çš„å¿«é€Ÿåˆ†æå’Œæ¨è
5. **æ•°æ®å®‰å…¨**ï¼šçº¯å‰ç«¯å®ç°ï¼Œæ•°æ®ä¸ç¦»å¼€æœ¬åœ°

è¿™ä¸ªå·¥å…·ç‰¹åˆ«é€‚åˆéœ€è¦æ™ºèƒ½æ¨èã€æ·±åº¦åˆ†æå’Œä¸ªæ€§åŒ–å­¦ä¹ æ”¯æŒçš„æ•™è‚²å·¥ä½œè€…ã€å­¦ç”Ÿå’Œç ”ç©¶äººå‘˜ï¼Œé€šè¿‡æ™ºèƒ½æ¨èç³»ç»Ÿå¯ä»¥æ˜¾è‘—æé«˜å­¦ä¹ æ•ˆç‡å’Œèµ„æºåˆ©ç”¨æ•ˆæœã€‚ -->
